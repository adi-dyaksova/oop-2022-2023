#include <iostream>

// Примерният клас от предната седмица. С тази разлика, че този път работим с динамична памет
class Number
{
public:
    int *x;

    // Функция, която ще виждаме често, когато работим с динамична памет. Тази функция ще ползваме главно
    // в деструктора и оператор =, но и навсякъде, където трябва да почистим текущо заделената памет за обекта.
    void cleanup()
    {
        delete x;
    }

    // Функция, която ще виждаме често, когато работим с динамична памет. Тази функция ще ползваме главно
    // в копи конструктора и оператор =, когато искаме да копираме състоянието на друг обек в текущия.
    void copy(const Number &other)
    {
        this->x = new int(*(other.x));
    }

    // Конструктор по подразбиране
    Number()
    {
        this->x = new int(0);
    }

    // Конструктор с един параметър
    Number(int n)
    {
        this->x = new int(n);
    }

    // Копи конструктор, който оказа кака ще се създава обект чрез друг(вече създаден) обект.
    // Задължително подаваме другия обект по референция, защото няма как да копираме обекти
    // без да имаме копи конструктор.
    Number(const Number &other)
    {
        copy(other);
    }

    // Деструктор - извиква се, когато се унищожава променлива от този тип. В тялото
    // на деструктор се грижим да освободим всички ресурси, които се ползват от обекта,
    // и които не се менежират за нас автоматично. Класическият пример за такъв тип ресурс
    // е динамичната памет.
    ~Number()
    {
        cleanup();
    }

    // Оператор за присвояване на един(вече създаден) обект към текущия(вече създаден) обект.
    // Конвенцията е да връщаме референция към текущия обект.
    Number &operator=(const Number &other)
    {
        // Задължително проверяваме дали не се опитваме да присвоим един обект на себе си,
        // за да избегнем проблеми с изтриването и заделянето на динамична памет.
        if (this != &other) // проверяваме дали адресите на двата обекта съвпадат
        {
            cleanup();   // Първо почистваме текущата памет, защото тя вече е заделена за разлика от случая при копи конструктора, където тепърва създаваме обекта
            copy(other); // И копираме другият обект в текущия
        }

        return *this;
    }

    void print()
    {
        std::cout << *x;
    }
};

void f(Number n)
{
    std::cout << "The function is called" << std::endl;

    return;
}

int main()
{
    Number n1(4);
    Number n2(n1); // Създаваме n2 чрез копи конструктора

    *(n2.x) = 10; // Променяме нещо в n2

    n1.print(); // Ако правилно сме имплементирали класа си, не трябва да има промяна в n1
    return 0;
}