# Тема 7, Свързан списък, 11.04.2023

## Тестове

```c++
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "../../lib/doctest.h"

int factorial(int number)
{
    return number <= 1 ? number : factorial(number - 1) * number;
}

TEST_CASE("testing the factorial function")
{
    CHECK(factorial(1) == 1);
    CHECK(factorial(2) == 2);
    CHECK(factorial(3) == 6);
    CHECK(factorial(10) == 3628800);
}
```

Библиотека - https://github.com/doctest/doctest/blob/master/doc/markdown/tutorial.md


## Свързан списък

<br/>

![Diagram](content/ll.png)

<br/>

## Задачи - [Решения](./solutions/)

### Зад. 1

Имплементирайте шаблонен клас `Node`, който ще представя един възел(една кутийка) в свързания списък. Класът трябва да съдържа в себе си реалната данна, която носи и указател към следващ възел(следваща кутийка). Добавете:

    * конструктор по подразбиране
    * конструктор с един параметър от шаблонния тип
    * конструктор с параметър от шаблонния тип и параметър, който е указател към друг възел

### Зад. 2

Създайте шаблонен клас `LinkedList`, който ще представя свързания списък. Преди да имплементирате голямата четворка, добавете няколко базови методи:

    * `void pushFront(const T&)` - добавя елемент в начало на списъка
    * `void popFront()` - премахва елемента в началото на списъка
    * `void print()` - отпечатва всички елементи на списъка
    * `T head()` - връща елемента в началото на списъка
    * `T get(int)` - връща елемента на i-та позиция

Напишете тестове за всеки от методите.

### Зад. 3

Имплементирайте голямата четворка за класа `LinkedList`. Напишете тестове за оператора за копиране и копи конструктора.

### Зад. 4

Добавете още функционалност(и тестове за нея) за добавяне, премахване и достъпване на елементи в списъка:

    * `void pushBack(const T&)` - добавя елемент към края на списъка
    * `void popBack()` - премаха елемент от края на списъка
    * `T last()` - връща последния елемент в списъка
    * `void insertAt(const T&, int)` - добавя елемент в списъка на дадена позиция
    * `void removeAt(int)` - премаха елемент в списъка на дадена позиция

### Зад. 5

Имплементирайте:

    * метод `LinkedList<T> reverse()`, който връща обърнатата версия на текущия списък (помислете как може да се направи метод reverse, който обръща текущия списък, а не връща нов такъв)
    * метод `LinkedList<U> map(std::function<U(T)>)`, която връща нов списък, елементите на който са получени след прилагането на функцията върху елементите на текущия списък
    * функция `LinkedList<T> merge(LinkedList<T>, LinkedList<T>)`, която обединява два предварително сортирани списъка в нов сортиран такъв